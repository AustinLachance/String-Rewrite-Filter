/*  
Filename: Subst16.c 
Student: Austin Lachance
Email: austin.lachance@yale.edu
Program Description: Subst16 allows the user to provide input via the Standard
Input. The user also provides a series of flags that represent filters. The
program takes the "FROM" string and replaces occurences of "FROM" found in the
input with the string "TO". The program allows for different types of
replacements (-q to replace the first instance of "FROM" in the input, -g to 
replace all instances of "FROM" that appear in the initial input, and -r to
replace each instance of "FROM" in the input as well as all additional
nstances of "FROM" found in the input that are generated by "TO" being
appended).  
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>	
#include <stdbool.h>
#include <math.h>
#include <ctype.h>
#include "getLine.h" //Class getLine function

//In each function:
//	o_string represents the original string taken in from the standard input
//	search represents the string we are searching for in o_string (or the FROM)
//	n_string represents the new string to be appended (or the TO)
//	replaced represents the function to be returned (The substituted str)

// Q_Flag replaces the first instance of search in o_string with n_string
char* Q_Flag(char* o_string, char* search, char* n_string);
// G_Flag replaces all instances of search in o_string  with n_string
char* G_Flag(char* o_string, char* search, char* n_string);
// R_Flag replaces each instance of search in o_string with n_string including
// additional instances created by the addition of n_string
char* R_Flag(char* o_string, char* search, char* n_string);
// Wildcard acts as a strstr function, but incorporates a wildcard '.'
char* wildcard(char* o_string, char* search);
// illegal_test tests if all commandline args are legal 
bool illegal_test(char* arg); 
// search_len finds length of "FROM" excluding escape chars
int search_len(char* search);
// caret_cat is used when replacing "FROM" with "TO". Allows for '^'
char* caret_cat(char* o_string, char* replaced, char* from, char* to);
//function to find size of "TO" with '^' accounted for
int mem_size(char* from, char* to); 

int main(int argc, char *argv[]) {

	//If no args are given, STOP
	if(argc < 1) {
		return 0;
	}
	//Test if args are legal
	bool illegal = false;
	for(int i=1; i <= (argc-1)/3; i++){
		if(strncmp(argv[3*i], "-", 1) != 0) {
			illegal = true;
			break;
		}
		else{
			if(illegal_test(argv[3*i])){
				illegal = true;
				break;
			}
		}
	}
	int temp_rgq = 0; //which flag -r, -g, or -q was specified 
	long int s_num = 0; //Which rule to jump to if replacement is SUCCESSFUL
	long int f_num = 0; //Which rule to jump to if replacement is UNSUCCESSFUL
	bool is_S = false; //Determines if a flag contains SUCCESS condition
	bool is_F = false; //Determines if a flag contains FAILURE condition
	bool success = false; //Determines if a replacement was SUCCESSFUL
	char* test; // for use as strtol's 2nd parameter
	if(illegal) {
		printf("Illegal option!\n");
		return 1;
	}
	else {
		char* line; //line from standard input
		while((line = getLine(stdin)) != NULL) {
			
			for(int i = 1; i <= (argc - 1)/3; i++) { //iterate through args
				s_num = 0;
				for(int j=1; j < strlen(argv[3*i]); j++) { //iterate through 

					if(argv[3*i][j] == 'r' || argv[3*i][j] == 'g' ||
					 argv[3*i][j] == 'q') {
					 	temp_rgq = argv[3*i][j];
					}
					else if(argv[3*i][j] == 'S') {
						is_S = true;
						if(j+1 < strlen(argv[3*i])) {
							if(isdigit(argv[3*i][j+1])) {
								s_num = strtol(argv[3*i] + j + 1, &test, 10);
								while(isdigit(argv[3*i][j+1]) != 0) {
									j++;
								}
							}
							else {
								s_num = 0;
							}		
						}	
					}
					else if(argv[3*i][j] == 'F') {
						is_F = true;
						if(j+1 < strlen(argv[3*i])) {
							if(isdigit(argv[3*i][j+1])) {
								f_num = strtol(argv[3*i] + j + 1, &test, 10);
								while(isdigit(argv[3*i][j+1]) != 0) {
									j++;
								}
							}
							else {
								f_num = 0;
							}
						}
					}

				}

				if(temp_rgq == 0 || temp_rgq == 'q') {
					if(wildcard(line, argv[3*i - 2]) != NULL) {
						success = true;
					}
					line = Q_Flag(line, argv[3*i - 2], argv[3*i - 1]);

					if(success && is_S) {
						if((3*s_num + 3) < argc) {
							i = s_num;
						}
						else{
							i = s_num;
						}
					}
					else if(!success && is_F) {
						if((3*f_num + 3) < argc) {
							i = f_num;
						}
						else {
							i = f_num;
						}
					}

					is_F = false;
					is_S = false;
					success = false;
				}

				else if(temp_rgq == 'g') {
					if(wildcard(line, argv[3*i - 2]) != NULL) {
						success = true;
					}
					line = G_Flag(line, argv[3*i - 2], argv[3*i - 1]);

					if(success && is_S) {
						if((3*s_num + 3) < argc) {
							i = s_num;
						}
						else {
							i = s_num;
						}
					}
					else if(!success && is_F) {
						if((3*f_num + 3) < argc) {
							i = f_num;
						}
						else {
							i = f_num;
						}
					}

					is_F = false;
					is_S = false;
					success = false;
				}

				else if(temp_rgq == 'r') {
					if(wildcard(line, argv[3*i - 2]) != NULL) {
						success = true;
					}
					line = R_Flag(line, argv[3*i - 2], argv[3*i - 1]);
					if(success && is_S) {
						if((3*s_num + 3) < argc) {
							i = s_num;
						}
						else {
							i = s_num;
						}
					}
					else if(!success && is_F) {
						if((3*f_num + 3) < argc) {
							i = f_num;
						}
						else {
							i = f_num;
						}
					}
					is_F = false;
					is_S = false;
					success = false;
				}
			}
			printf("%s", line);
			free(line);
		}
		free(line);
		return 0;
	}
	
}

bool illegal_test(char* arg) {

	bool illegal = false; 

	// Make sure all chars are q, r, g, S, F, or trailing digits
	for(int i=1; i < strlen(arg); i++) {
		if(arg[i] != 'r' && arg[i] != 'g' && arg[i]!= 'q') {
			if(arg[i] == 'S') {
			}
			if(arg[i] == 'S' || arg[i] == 'F') {
				if(i+1 < strlen(arg)) {
					if(isdigit(arg[i+1])) {
						while(isdigit(arg[i+1]) != 0){
							i++;
						}
					}
				}
			}
			else {
				illegal = true;
				break;
			}
		}
	}
	return illegal;
}



char* Q_Flag(char* o_string, char* search, char* n_string){

	
	int len_dif = n_string - search; //size difference between two strings
	// Replaced serves as the final substituted version of o_string
	char* replaced = malloc(strlen(o_string) + len_dif + 1); 
	for(size_t i = 0; i < strlen(o_string) + len_dif + 1; i++) {
		replaced[i] = '\0';
	}
	char* find_str = wildcard(o_string, search); //location of search in o_str
	size_t num_char = find_str - o_string; //where search is relative to o_str

	//if search is in o_string then replace it with n_string
	if(find_str) {
		strncpy(replaced, o_string, num_char);

		//Allow memory for "TO" to be added
		replaced = realloc(replaced, strlen(replaced) + 1 + 
			mem_size(search, n_string));

		caret_cat(o_string, replaced, search, n_string);

		//Memory for the rest of the original string to be added
		replaced = realloc(replaced, strlen(replaced) + 1 + 
			strlen(find_str + search_len(search)));

		strcat(replaced, (find_str + search_len(search)));
	}

	else {
		free(replaced);
		return(o_string);
	}
	free(o_string);
	return replaced;

}


char* G_Flag(char* o_string, char* search, char* n_string) {

	char* freehere = o_string; //mark o_string location
	char* find_str = "\0"; //location of search found in o_string
	char* replaced = malloc(strlen(o_string)+1); //str to be returned
	for(size_t i = 0; i < (strlen(o_string) + 1); i++) {
		replaced[i] = '\0';
	}

	size_t num_char = 0;

	// Keep moving along o_string as long as search still exists inside of it
	while(wildcard(o_string, search) != NULL) {
		find_str = wildcard(o_string, search);
		num_char = find_str - o_string;
		replaced = realloc(replaced, strlen(replaced) + 1 + num_char);
		strncat(replaced, o_string, num_char);

		replaced = realloc(replaced, strlen(replaced) + 1 + 
			mem_size(search, n_string));

		caret_cat(o_string, replaced, search, n_string);
		o_string = find_str + search_len(search);
	}
	replaced = realloc(replaced, strlen(replaced) + 1 + strlen(o_string));
	strcat(replaced, o_string);
	free(freehere);
	return replaced;
}


char* R_Flag(char* o_string, char* search, char* n_string) {

	// first char of search found in o_string (if any)
	char* find_str = "\0"; 
	// substituted string to be returned
	char* replaced = malloc(strlen(o_string)+1); 

	for(size_t i = 0; i < strlen(o_string); i++) {
		replaced[i] = '\0';
	}
	
	size_t num_char = 0;

	// as long as search can be found in o_string
	while(wildcard(o_string, search) != NULL) {
		char* freehere = o_string;
		// str to hold TO replacement as well as o_string after FROM
		char* new_o_string = malloc(strlen(o_string) + 1);
		for(size_t i = 0; i < strlen(o_string); i++) {
			new_o_string[i] = '\0';
		}
		find_str = wildcard(o_string, search);
		num_char = find_str - o_string;
		replaced = realloc(replaced, strlen(replaced) + num_char + 1);
		strncat(replaced, o_string, num_char);
		//chars remaining in o_string after FROM
		o_string = find_str + search_len(search); 

		new_o_string = realloc(new_o_string, strlen(n_string) + 1 + 
			strlen(o_string) + 1);

		strcat(new_o_string, n_string); 
		strcat(new_o_string, o_string);	
		//o_string now equals TO + chars remaining in original o_string
		o_string = new_o_string; 
		free(freehere); //free our original o_string
	}
	replaced = realloc(replaced, strlen(replaced) + strlen(o_string) + 1);
	strcat(replaced, o_string);
	free(o_string);
	return replaced;


}


char* wildcard(char* o_string, char* search) {
	char* location = "\0"; //index of 1st char of search in o_string if any
	int index = 0;
	int j = 0; //iterate through search
	int k = 0; //iterate through o_string (set = i, but doesnt change i value)
	bool escaped = false;

	for(int i = 0; i < strlen(o_string); i++){
		k = i;
		//If the a char in o_string matches the first char in search
		if(o_string[k] == search[0] || search[0] == '.' || search[0] == '@') {
			index = i;

			while(j <= strlen(search)) {
				//if search reaches '\0' then search exists in o_string
				if(search[j] == 0) {
					location = o_string + index;
					return location;
				}
				// dont mistake \n for a wildcard char
				if((search[j] == '.') && !escaped) {
					if(o_string[k] == '\n') {
						return (char*) 0;
					}
				}
				//if escaped char then don't advance o_string, only search
				else if(search[j] == '@' && !escaped) {
					if(j + 1 < strlen(search)) {
						if(search[j+1] == '.' || search[j+1] ==  '@') {
							escaped = true;
							k--;
						}
					}
					else {
						if(search[j] != o_string[k]) {
							break;
						}
					}
				}
				else if(search[j] != o_string[k]) {
					break;
				}
				else if(escaped) {
					escaped = false; 
				}
				j++;
				k++;
			}
			j=0;
		}
		escaped = false;
	}
	//if o_string is exhausted with no success finding search, return NULL
	return (char*) 0;
}

int search_len(char* search) {
	int search_len = 0; // length of search
	bool escaped = false;

	for(int j=0; j<strlen(search); j++) {
		//if @ -> @ or . then first @ is an escape char and doesnt increase len
		if(search[j] == '@' && j+1 < strlen(search) && !escaped) {
			if(search[j+1] == '.' || search[j+1] == '@'){
				escaped = true;
			}
			else {
				search_len++;
			}
		}
		else{
			escaped = false;
			search_len++;
		}
	}
	return search_len;
}

int mem_size(char* from, char* to) {
	int i =0;
	int memsize = 0; // length of to after ^ subs and escaped @ chars
	bool escaped = false; // true when @ or . follows an @

	while(to[i] != '\0') {
		//dont increase memsize for an @ followed by an @ or .
		if(to[i] == '@' && i + 1 < strlen(to) && !escaped) {
			if(to[i+1] == '@' || to[i+1] == '^') {
				escaped = true;
			}
			else {
				memsize++;
			}
		}
		// if "TO" has a non-escaped ^ then increase memsize by size of FROM
		else if(to[i] == '^' && !escaped) {
			memsize += search_len(from);
		}
		else {
			escaped = false;
			memsize++;
		}
		i++;
	}
	return memsize;
}

char* caret_cat(char* o_string, char* replaced, char* from, char* to) {

	char* new_to = to; //mark location of to
	size_t i = 0;
	bool escaped = false; // true if @ followed by @ or .

	while(to[i] != '\0') {
		if(to[i] == '@' && i + 1 < strlen(to) && !escaped) {
			if(to[i+1] == '@' || to[i+1] == '^') {
				escaped = true;
			}
			else {
				strcat(replaced, "@");
			}
		}
		// when there is a ^ strncat chars from o_string where "FROM" was found
		// in o_string to replaced
		else if(to[i] == '^' && !escaped) {
			strncat(replaced, wildcard(o_string, from), search_len(from));
		}
		else {
			escaped = false;
			strncat(replaced, new_to, 1);
		}
		i++;
		new_to++;
	}
	return replaced;
}



